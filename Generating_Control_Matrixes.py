import numpy as np
import math
# порождающая матрица G
G = np.array([[1, 1, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 1, 1, 0, 0],
     [0, 0, 1, 1, 0, 1, 0, 1],
     [1, 0, 0, 1, 1, 0, 1, 0]])

# массив для хранения числа единиц в комбинациях
d_min = []

# 16 кодовых слов от 0 до 15 в двоичной СС shape[0] = 4 = функция подсчета числа строк
for i in range(int(math.pow(2, G.shape[0]))):

    s = str(bin(i)[2:].zfill(4))  # формируем строку формата 0000
    a = list(s)  # преобразуем ее в список
    a = [int(item) for item in a]
    c = np.matmul(a, G)  # умножение порождающей матрицы на кодовое слово
    counter = 0  # счётчик числа единиц в кодовом слове
    for k in range(len(c)):  # проверка на четность получившегося вектора
        if c[k] % 2 == 0:
            c[k] = 0
        if c[k] % 2 == 1:
            c[k] = 1
            counter += 1
    d_min.append(counter)  # записали число единиц в комбинамции в массив
    print(str(i + 1) + '-я кодовая комбинация: ' + str(c))

d_min.pop(0)  # убрали первый элемент, так как он для нулевой комбинации
print('Кодовое расстояние: ' + str(min(d_min)) + '\n')


A = [[0, 0, 0, 1],
     [0, 1, 1, 1],
     [1, 1, 1, 0],
     [1, 0, 1, 1]]

A = np.multiply(-1, A)
A = np.transpose(A)

H = np.hstack((A, np.identity(4)))  # нашли проверочную матрицу
print('Проверочная матрица : \n' + str(H) + '\n')

# транспонируем проыерную матрицу для нахождения произвденения GHтрансп
H = np.transpose(H)

MUL = np.matmul(G, H)  # матрица произведения

for i in range(MUL.shape[0]):  # цикл проверки на чётность
    for j in range(MUL.shape[1]):
        if MUL[i][j] % 2 == 0:
            MUL[i][j] = 0
        if (MUL[i][j] % 2 == 1) and (MUL[i][j] < 0):
            MUL[i][j] = -1
        if (MUL[i][j] % 2 == 1) and (MUL[i][j] > 0):
            MUL[i][j] = 1

print('Произведение порождающей и траспонтированной проверчной матриц:\n' + str(MUL))
